# Create samples, correct for offset, and extend
# rmvnorm(n,mean,sigme) ~ generate n samples from N(0,I) distribution
S <- rmvnorm(n, mean=rep(0,d),sigma = diag(1,d)) %*%  t(Basis)
S <- S + matrix(rep(offset,n),n,d,byrow=T)
S <- cbind(S,1)
# compute the class assignments
y <- as.vector(sign(S %*% w))
# add corrective factors to points that lie on the hyperplane.
S[y==0,1:d] <- S[y==0,1:d] + runif(1,-0.5,0.5)*10^(-4)
y = as.vector(sign(S %*% w))
return(list(S=S, y=y))
} # end function fakedata
s
S
getwd()
setwd
source(file = )
setwd()
source(file =            )
getwd()
setwd(C:/Users/Administrator/Desktop)
setwd(C://Users/Administrator/Desktop/)
setwd("C:/Users/Administrator/Desktop/")
source(file = "fakedata.r")
source(file = "fakedata.r")
classify<-function(S,z){
n<-nrow(S)
yhat<-sign(S%*%z)
return(yhat)
}
Cp.z<-function(z,S,y){
return(t(classify(S,z)!=y)%*%abs(S%*%z))
}
Perceptrain<-function(S,y){
d<-ncol(S)
n<-nrow(S)
Z_history<-c()
z<-runif(d)
Cp<-Cp.z(z,S,y)
k=0
while(Cp!=0){
k<-k+1
alpha<-1/k
yhat<-classify(S,z)
deriv.Cp<-t(S)%*%((yhat!=y)*(-y))
z<-z-alpha*deriv.Cp
Z_history<-c(Z_history,z)
Cp<-Cp.z(z,S,y)
}
Z_history<-matrix(Z_history,ncol=d,byrow = T)
return(list(z=z,Z_history=Z_history))
}
data<-fakedata(c(-2,3,1),100)
## Loading required package: MASS
## Loading required package: mvtnorm
lst<-Perceptrain(data$S,data$y)
data<-fakedata(c(-2,3,1),100)
## Loading required package: MASS
## Loading required package: mvtnorm
lst<-Perceptrain(data$S,data$y)
z<-lst$z
Z_history<-lst$Z_history
data.test<-fakedata(c(-2,3,1),100)
sum(classify(data.test$S,z)==data.test$y)
z
plot(data.test$S[,1],data.test$S[,2],col=data.test$y+3,asp=1,pch="+")
abline(-z[3]/z[2],-z[1]/z[2],col=1)
plot(data.test$S[,1],data.test$S[,2],col=data.test$y+3,asp=1, xlab="",
ylab ="", main ="test dataset and the classifier hyperplane")
abline(-z[3]/z[2],-z[1]/z[2],col=1)
plot(data.test$S[,1],data.test$S[,2],col=data.test$y+3,asp=1, xlab="",
ylab ="", main ="test dataset and the classifier hyperplane")
abline(-z[3]/z[2],-z[1]/z[2],col=1)
plot(data$S[,1],data$S[,2],col=data$y+3,asp=1,pch="+")
n<-nrow(Z_history)
color<-rainbow(n)
for(i in 1:n){
if(i==n){
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],col=1,lty=1,lwd=2);break}
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],col=color[i],lty=3)
}
plot(data.test$S[,1],data.test$S[,2],col=data.test$y+3,asp=1, xlab="",
ylab ="", main ="test dataset and the classifier hyperplane")
abline(-z[3]/z[2],-z[1]/z[2],col=1)
plot(data$S[,1],data$S[,2],col=data$y+3,asp=1,xlab="", ylab="",
main="trajectory of the algorithm by visualizing Z_history")
n<-nrow(Z_history)
for(i in 1:n){
if(i==n){
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],col=1,lty=1,lwd=2);
break}
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],col=color[i],lty=3)
}
plot(data.test$S[,1],data.test$S[,2],col=data.test$y+3,asp=1, xlab="",
ylab ="", main ="test dataset and the classifier hyperplane")
abline(-z[3]/z[2],-z[1]/z[2],col=1)
plot(data$S[,1],data$S[,2],col=data$y+3,asp=1,xlab="", ylab="",
main="trajectory of the algorithm by visualizing Z_history")
n<-nrow(Z_history)
color<-rainbow(n)
for(i in 1:n){
if(i==n){abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],col=1,lty=1,lwd=2);break}
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],col=color[i],lty=3)
}
plot(data.test$S[,1],data.test$S[,2],col=data.test$y+3,asp=1, xlab="",
ylab ="", main ="test dataset and the classifier hyperplane")
abline(-z[3]/z[2],-z[1]/z[2],col=1)
plot(data$S[,1],data$S[,2],col=data$y+3,asp=1,xlab="", ylab="",
main="trajectory of the algorithm by visualizing Z_history")
n<-nrow(Z_history)
for(i in 1:n){
if(i==n){
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],
col=1,lty=1,lwd=2);
break}
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],
col=color[i],lty=3)
}
source(file = "fakedata.r")
classify<-function(S,z){
n<-nrow(S)
yhat<-rep(NA,n)
yhat<-sign(S%*%z)
return(yhat)
}
Cp.z<-function(z,S,y){
return(t(classify(S,z)!=y)%*%abs(S%*%z))
}
Perceptrain<-function(S,y){
d<-ncol(S)
n<-nrow(S)
Z_history<-c()
z<-runif(d)
Cp<-Cp.z(z,S,y)
k=0
while(Cp!=0){
k<-k+1
alpha<-1/k
yhat<-classify(S,z)
deriv.Cp<-t(S)%*%((yhat!=y)*(-y))
z<-z-alpha*deriv.Cp
Z_history<-c(Z_history,z)
Cp<-Cp.z(z,S,y)
}
Z_history<-matrix(Z_history,ncol=d,byrow = T)
return(list(z=z,Z_history=Z_history))
}
data<-fakedata(c(-2,3,1),100)
lst<-Perceptrain(data$S,data$y)
z<-lst$z
Z_history<-lst$Z_history
data.test<-fakedata(c(-2,3,1),100)
sum(classify(data.test$S,z)==data.test$y)
z
data<-fakedata(c(-2,3,1),100)
lst<-Perceptrain(data$S,data$y)
z<-lst$z
Z_history<-lst$Z_history
data.test<-fakedata(c(-2,3,1),100)
sum(classify(data.test$S,z)==data.test$y)
z
plot(data.test$S[,1],data.test$S[,2],col=data.test$y+3,asp=1, xlab="",
ylab ="", main ="test dataset and the classifier hyperplane")
abline(-z[3]/z[2],-z[1]/z[2],col=1)
plot(data$S[,1],data$S[,2],col=data$y+3,asp=1,xlab="", ylab="",
main="trajectory of the algorithm by visualizing Z_history")
n<-nrow(Z_history)
for(i in 1:n){
if(i==n){
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],
col=1,lty=1,lwd=2);
break}
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],
col=color[i],lty=3)
}
plot(data.test$S[,1],data.test$S[,2],col=data.test$y+3,asp=1, xlab="",
ylab ="", main ="test dataset and the classifier hyperplane")
abline(-z[3]/z[2],-z[1]/z[2],col=1)
plot(data$S[,1],data$S[,2],col=data$y+3,asp=1,xlab="", ylab="",
main="trajectory of the algorithm by visualizing Z_history")
n<-nrow(Z_history)
for(i in 1:n){
if(i==n){
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],
col=1,lty=1,lwd=2);
break}
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],
lty=3)
}
plot(data.test$S[,1],data.test$S[,2],col=data.test$y+3,asp=1, xlab="",
ylab ="", main ="test dataset and the classifier hyperplane")
abline(-z[3]/z[2],-z[1]/z[2],col=1)
plot(data$S[,1],data$S[,2],col=data$y+3,asp=1,xlab="", ylab="",
main="trajectory of the algorithm by visualizing Z_history")
n<-nrow(Z_history)
for(i in 1:n){
if(i==n){
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],
col=1,lty=1,lwd=2);
break}
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],
col = 10, lty=3)
}
plot(data.test$S[,1],data.test$S[,2],col=data.test$y+3,asp=1, xlab="",
ylab ="", main ="test dataset and the classifier hyperplane")
abline(-z[3]/z[2],-z[1]/z[2],col=1)
plot(data$S[,1],data$S[,2],col=data$y+3,asp=1,xlab="", ylab="",
main="trajectory of the algorithm by visualizing Z_history")
n<-nrow(Z_history)
for(i in 1:n){
if(i==n){
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],
col=1,lty=1,lwd=2);
break}
abline(-Z_history[i,3]/Z_history[i,2],-Z_history[i,1]/Z_history[i,2],
col = 3, lty=3)
}
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
setView(lng=-95.7, lat=37.1, zoom=4 )%>%
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang/app')
runApp('yixiang/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
runApp('yixiang2/app')
library(RCurl)
library(RCurl)
library(RJSONIO)
library(leaflet)
library(igraph)
library(geosphere)
load("./Nodes.RData")
load("./Segments.RData")
load("./Original Segments.RData")
stations<-read.csv("./data.csv",header=TRUE)
geocode<-function(add){
root<-"https://maps.google.com/maps/api/geocode/"
url<-paste0(root,"json?address=",add,"&key=AIzaSyC82ht4goSYy9M7Dp9tXc-vO9qxCoeF0jM")
u<-getURL(URLencode(url))
u<-fromJSON(u,simplify=FALSE)
if (u$status=="OK"){
lat<-as.numeric(u$results[[1]]$geometry$location$lat)
lng<-as.numeric(u$results[[1]]$geometry$location$lng)
location_type<-u$results[[1]]$geometry$location_type
formatted_address<-u$results[[1]]$formatted_address
return(c(lat,lng,location_type,formatted_address))
} else {
return(rep(NA,4))
}
}
Nearest.Node<-function(Nodes=Nodes,Coord){
D = (Nodes[,1]-Coord[1])^2+(Nodes[,2]-Coord[2])^2
return(Nodes[which.min(D),"ID"])
}
sift.station<-function(scoord,ecoord){
station<-data.frame(lat=as.numeric(stations$Latitude),
lng=as.numeric(stations$Longitude))
x<-ecoord-scoord
station.dir<-data.frame(lat=(station$lat-scoord[2]),lng=(station$lng-scoord[1]))
station.l<-station.dir$lat^2+station.dir$lng^2
l<-station.dir$lat*x[2]+station.dir$lng*x[1]
l<-l/station.l
i1<-which.max(l)
i2<-which.max(l[-i1])
return(c(station$lat[i1],station$lng[i1],station$lat[i2],station$lng[i2]))
}
Shortest<-function(New.Segments,U.Nodes,Start.ID,End.ID){
float <- 0.01
Start <- U.Nodes[Start.ID,]
End <- U.Nodes[End.ID,]
Segments <- New.Segments
Segments$Distance<-rep(1,nrow(Segments))
df <- as.data.frame(Segments[c("Start","End","Distance")])
names(df) <- c("start_node","end_node","dist")
gdf <- graph.data.frame(df, directed=FALSE)
SHORT.Go = shortest_paths(gdf,as.character(Start.ID),as.character(End.ID),weights = E(gdf)$dist)$vpath
EDGE.Go = as.numeric(shortest_paths(gdf,as.character(Start.ID),as.character(End.ID),output = "epath",weights = E(gdf)$dist)$epath[[1]])
names<-V(gdf)$name
Sequence.Go =as.numeric(lapply(SHORT.Go,function(x){names[x]})[[1]])
EDGE.Back = rev(EDGE.Go)
EDGE.index = c(EDGE.Go,EDGE.Back[-1])
EDGE = Segments[EDGE.index,]
Sequence.Back = rev(Sequence.Go)
Sequence = c(Sequence.Go,Sequence.Back[-1])
return(list(Path = EDGE,edge.index =c(EDGE.Go,EDGE.Back[-1]),Nodes.Go = Nodes[Sequence.Go,1:2],Nodes.Back = Nodes[Sequence.Back,1:2]))
}
GetLength<-function(Edge){
GL<-function(r){
return(distm(r[1:2],r[3:4],fun = distHaversine)[,1]/1000)
}
D = apply(Edge,1,GL)
return(sum(D))
}
Findpath<-function(start,end,Nodes=Nodes,Segments=Segments,stations=stations){
startCoord<-as.numeric(geocode(start)[2:1])
start.Node<- Nearest.Node(Nodes,startCoord)
endCoord<-as.numeric(geocode(end)[2:1])
end.Node <- Nearest.Node(Nodes,endCoord)
fuel.stat<-sift.station(startCoord,endCoord)[2:1]
station.Node<-Nearest.Node(Nodes,fuel.stat)
Path1 <- Shortest(Segments,Nodes,start.Node,station.Node)
Path2 <- Shortest(Segments,Nodes,station.Node,end.Node)
Path <-list(Path=rbind(Path1$Path,Path2$Path),
edge.index=c(Path1$edge.index,Path2$edge.index),
Nodes.Go=rbind(Path1$Nodes.Go,Path2$Nodes.Go),
Nodes.Back=rbind(Path2$Nodes.Back,Path1$Nodes.Back))
#Edge.index = Path$edge.index
#Edge = Path$Path
#colnames(startCoord) = c("Longtitude","Latitude")
#colnames(endCoord) = c("Longtitude","Latitude")
Route.Go = rbind(startCoord,Path$Nodes.Go,endCoord)
Route.Back = rbind(endCoord,Path$Nodes.Back,startCoord)
#EDGE = Segments[Edge.index,]
#Length = GetLength(EDGE)
#Route.Score = sum(1/Edge$Distance)/nrow(Edge)
#,Edge = EDGE ,Length = Length, Score = Route.Score,End.Point = endCoord))
return(list(go=Route.Go,back=Route.Back))
}
stations<-read.csv("./data.csv",header=TRUE)
getwd(0)
getwd()
getwd()
runApp('yixiang2/app')
setwd("C:/Users/Administrator/Desktop/yixiang2")
runApp('app')
stations<-read.csv("./data.csv",header=TRUE)
library(readr)
data <- read_csv("C:/Users/Administrator/Desktop/yixiang2/data/data.csv")
View(data)
stations<-read.csv("C:/Users/Administrator/Desktop/yixiang2/data/data.csv",header=TRUE)
geocode<-function(add){
root<-"https://maps.google.com/maps/api/geocode/"
url<-paste0(root,"json?address=",add,"&key=AIzaSyC82ht4goSYy9M7Dp9tXc-vO9qxCoeF0jM")
u<-getURL(URLencode(url))
u<-fromJSON(u,simplify=FALSE)
if (u$status=="OK"){
lat<-as.numeric(u$results[[1]]$geometry$location$lat)
lng<-as.numeric(u$results[[1]]$geometry$location$lng)
location_type<-u$results[[1]]$geometry$location_type
formatted_address<-u$results[[1]]$formatted_address
return(c(lat,lng,location_type,formatted_address))
} else {
return(rep(NA,4))
}
}
Nearest.Node<-function(Nodes=Nodes,Coord){
D = (Nodes[,1]-Coord[1])^2+(Nodes[,2]-Coord[2])^2
return(Nodes[which.min(D),"ID"])
}
sift.station<-function(scoord,ecoord){
station<-data.frame(lat=as.numeric(stations$Latitude),
lng=as.numeric(stations$Longitude))
x<-ecoord-scoord
station.dir<-data.frame(lat=(station$lat-scoord[2]),lng=(station$lng-scoord[1]))
station.l<-station.dir$lat^2+station.dir$lng^2
l<-station.dir$lat*x[2]+station.dir$lng*x[1]
l<-l/station.l
i1<-which.max(l)
i2<-which.max(l[-i1])
return(c(station$lat[i1],station$lng[i1],station$lat[i2],station$lng[i2]))
}
library(RCurl)
library(RJSONIO)
library(leaflet)
library(igraph)
library(geosphere)
load("./Nodes.RData")
load("./Segments.RData")
load("./Original Segments.RData")
stations<-read.csv("C:/Users/Administrator/Desktop/yixiang2/data/data.csv",header=TRUE)
geocode<-function(add){
root<-"https://maps.google.com/maps/api/geocode/"
url<-paste0(root,"json?address=",add,"&key=AIzaSyC82ht4goSYy9M7Dp9tXc-vO9qxCoeF0jM")
u<-getURL(URLencode(url))
u<-fromJSON(u,simplify=FALSE)
if (u$status=="OK"){
lat<-as.numeric(u$results[[1]]$geometry$location$lat)
lng<-as.numeric(u$results[[1]]$geometry$location$lng)
location_type<-u$results[[1]]$geometry$location_type
formatted_address<-u$results[[1]]$formatted_address
return(c(lat,lng,location_type,formatted_address))
} else {
return(rep(NA,4))
}
}
Nearest.Node<-function(Nodes=Nodes,Coord){
D = (Nodes[,1]-Coord[1])^2+(Nodes[,2]-Coord[2])^2
return(Nodes[which.min(D),"ID"])
}
sift.station<-function(scoord,ecoord){
station<-data.frame(lat=as.numeric(stations$Latitude),
lng=as.numeric(stations$Longitude))
x<-ecoord-scoord
station.dir<-data.frame(lat=(station$lat-scoord[2]),lng=(station$lng-scoord[1]))
station.l<-station.dir$lat^2+station.dir$lng^2
l<-station.dir$lat*x[2]+station.dir$lng*x[1]
l<-l/station.l
i1<-which.max(l)
i2<-which.max(l[-i1])
return(c(station$lat[i1],station$lng[i1],station$lat[i2],station$lng[i2]))
}
Shortest<-function(New.Segments,U.Nodes,Start.ID,End.ID){
float <- 0.01
Start <- U.Nodes[Start.ID,]
End <- U.Nodes[End.ID,]
Segments <- New.Segments
Segments$Distance<-rep(1,nrow(Segments))
df <- as.data.frame(Segments[c("Start","End","Distance")])
names(df) <- c("start_node","end_node","dist")
gdf <- graph.data.frame(df, directed=FALSE)
SHORT.Go = shortest_paths(gdf,as.character(Start.ID),as.character(End.ID),weights = E(gdf)$dist)$vpath
EDGE.Go = as.numeric(shortest_paths(gdf,as.character(Start.ID),as.character(End.ID),output = "epath",weights = E(gdf)$dist)$epath[[1]])
names<-V(gdf)$name
Sequence.Go =as.numeric(lapply(SHORT.Go,function(x){names[x]})[[1]])
EDGE.Back = rev(EDGE.Go)
EDGE.index = c(EDGE.Go,EDGE.Back[-1])
EDGE = Segments[EDGE.index,]
Sequence.Back = rev(Sequence.Go)
Sequence = c(Sequence.Go,Sequence.Back[-1])
return(list(Path = EDGE,edge.index =c(EDGE.Go,EDGE.Back[-1]),Nodes.Go = Nodes[Sequence.Go,1:2],Nodes.Back = Nodes[Sequence.Back,1:2]))
}
GetLength<-function(Edge){
GL<-function(r){
return(distm(r[1:2],r[3:4],fun = distHaversine)[,1]/1000)
}
D = apply(Edge,1,GL)
return(sum(D))
}
Findpath<-function(start,end,Nodes=Nodes,Segments=Segments,stations=stations){
startCoord<-as.numeric(geocode(start)[2:1])
start.Node<- Nearest.Node(Nodes,startCoord)
endCoord<-as.numeric(geocode(end)[2:1])
end.Node <- Nearest.Node(Nodes,endCoord)
fuel.stat<-sift.station(startCoord,endCoord)[2:1]
station.Node<-Nearest.Node(Nodes,fuel.stat)
Path1 <- Shortest(Segments,Nodes,start.Node,station.Node)
Path2 <- Shortest(Segments,Nodes,station.Node,end.Node)
Path <-list(Path=rbind(Path1$Path,Path2$Path),
edge.index=c(Path1$edge.index,Path2$edge.index),
Nodes.Go=rbind(Path1$Nodes.Go,Path2$Nodes.Go),
Nodes.Back=rbind(Path2$Nodes.Back,Path1$Nodes.Back))
#Edge.index = Path$edge.index
#Edge = Path$Path
#colnames(startCoord) = c("Longtitude","Latitude")
#colnames(endCoord) = c("Longtitude","Latitude")
Route.Go = rbind(startCoord,Path$Nodes.Go,endCoord)
Route.Back = rbind(endCoord,Path$Nodes.Back,startCoord)
#EDGE = Segments[Edge.index,]
#Length = GetLength(EDGE)
#Route.Score = sum(1/Edge$Distance)/nrow(Edge)
#,Edge = EDGE ,Length = Length, Score = Route.Score,End.Point = endCoord))
return(list(go=Route.Go,back=Route.Back))
}
runApp('app')
getwd()
runApp('app')
